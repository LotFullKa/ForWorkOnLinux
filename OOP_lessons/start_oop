															
																"Введение в ООП"
	1) Классы  и структуры
			
			class D {
			public:							\\паблик следует писать первее привата, чтобы класс был читабельнее
			
			private:
				
			};
			
		Если в классе только часть паблик, стоит реализовать его как struct
		
		Работа с методоами:
			(x ? y : z).f();
			
		если сделать указатель, это сработает плохо
		
		(*p).f(); 			--плохо
		p -> f();			--хорошо ! (специальный синтаксис для работы с методами через указатель)
		
		
										Я очень много пропустил, но вот что в кратце написано на доске
		
		3.2) конструкции ! 
		
		class String {
		public:
			String() {
				str = new char[10];
				sz = 0;
			}
			string (size_t n) {	... }
		private:
			char str = nullptr;
			size_t sz = 0; 
			
			\\ Операторы присваивания !
			
			~String() {
				delete[] str;
			}
			
		4) Копирование, копирующие методы и "правило трех"
			
		5) Константные методы
			
			Методы вашего класса могу не модефицировать объект, тогда они "константные",
			точнее мы можем объявить их таковыми
			
			Константные методы можно применять к неконстантым объектам,
			а применять не константные методы к константым объектам нельзя
			
			"Всегда нужно дописывать const к константым методам"
			
			void f() const {
			
			}
			mutable int n = 1; \\ а может ?! n++;
			
			представим что метод const, а нам понадобилось, например, менять счетчик, считая количество
			вызова метода
			Ради этого снимать с метода прекрасный флаг const ??!
			Есть оператор "антиконст" - mutable позволяющий полю меняться в константном методе.
			
			перегрузка, константы, крик души
			
			const char& operator[](size_t n);		- это константная ссылка, а вот под ней объект нет!
			const char& operator[](size_t n) const; - а сейчас кошерно !
			
		5) Списки инициализации конструкции
		
			int z = 5;
			
			struct S {
			int x;
			const int y;
													\\ называется список инициализации
			S (int&x, int y) :x(x), y(y) {			\\важная хуета, внешне то что в аргументах,  внутри скобок то что внутри класса
				this -> x = x; 			- важно что это поменяет  внешний х а не внутре классовый
			}
			
			зачем нужны такие списки? Это экономит нам нам количество копирований при инициализации класса
			
		7) Друзья
			
			Если нам захочется что другой класс или функция видела приватные методы this класса
			Занятно дружба не взаимна и не транзитивна !  (со смыслом)
			
			friend
			
			это пишется внутри класса, чтобы объявить f или C
			friend void f(int);
			friend class C;
			
			Совет: имейте меньше друзей ! (со смыслом) каждый друг потенциальная угроза для вас ! 
			
			Пример WTF у нас есть поток и нужно как-то объявить оператор ввода без вызова через точку
			
			istream operator >> (istream&; string& x)
			friend istream operator >> (istream&; string& x)		- работает, единственый твой верный друг !
		






















