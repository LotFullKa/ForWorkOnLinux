															
																"Введение в ООП"
	1) Классы  и структуры
			
			class D {
			public:							\\паблик следует писать первее привата, чтобы класс был читабельнее
			
			private:
				
			};
			
		Если в классе только часть паблик, стоит реализовать его как struct
		
		Работа с методоами:
			(x ? y : z).f();
			
		если сделать указатель, это сработает плохо
		
		(*p).f(); 			--плохо
		p -> f();			--хорошо ! (специальный синтаксис для работы с методами через указатель)
		
		
										Я очень много пропустил, но вот что в кратце написано на доске
		
		3.2) конструкции ! 
		
		class String {
		public:
			String() {
				str = new char[10];
				sz = 0;
			}
			string (size_t n) {	... }
		private:
			char str = nullptr;
			size_t sz = 0; 
			
			\\ Операторы присваивания !
			
			~String() {
				delete[] str;
			}
			
		4) Копирование, копирующие методы и "правило трех"
			
		5) Константные методы
			
			Методы вашего класса могу не модефицировать объект, тогда они "константные",
			точнее мы можем объявить их таковыми
			
			Константные методы можно применять к неконстантым объектам,
			а применять не константные методы к константым объектам нельзя
			
			"Всегда нужно дописывать const к константым методам"
			
			void f() const {
			
			}
			mutable int n = 1; \\ а может ?! n++;
			
			представим что метод const, а нам понадобилось, например, менять счетчик, считая количество
			вызова метода
			Ради этого снимать с метода прекрасный флаг const ??!
			Есть оператор "антиконст" - mutable позволяющий полю меняться в константном методе.
			
			перегрузка, константы, крик души
			
			const char& operator[](size_t n);		- это константная ссылка, а вот под ней объект нет!
			const char& operator[](size_t n) const; - а сейчас кошерно !
			
		5) Списки инициализации конструкции
		
			int z = 5;
			
			struct S {
			int x;
			const int y;
													\\ называется список инициализации
			S (int&x, int y) :x(x), y(y) {			\\важная хуета, внешне то что в аргументах,  внутри скобок то что внутри класса
				this -> x = x; 			- важно что это поменяет  внешний х а не внутре классовый
			}
			
			зачем нужны такие списки? Это экономит нам нам количество копирований при инициализации класса
			
		7) Друзья
			
			Если нам захочется что другой класс или функция видела приватные методы this класса
			Занятно дружба не взаимна и не транзитивна !  (со смыслом)
			
			friend
			
			это пишется внутри класса, чтобы объявить f или C
			friend void f(int);
			friend class C;
			
			Совет: имейте меньше друзей ! (со смыслом) каждый друг потенциальная угроза для вас ! 
			
			Пример WTF у нас есть поток и нужно как-то объявить оператор ввода без вызова через точку
			
			istream operator >> (istream&; string& x)
			friend istream operator >> (istream&; string& x)		- работает, единственый твой верный друг !
			
		05.02.20
		Мы заканчиваем говорить о классах
		
		8) explicit
		
			допустим есть конструктор строки от числа
			
			string(size_t n){};
			
			может возникнуть проблема : 
			
			string s1 = s + 'a';
				f(1)
			
			такая команда запретит вызывать неявно этот конструктор, то есть этот конструктор можно вызвать только явно, черным по белому блэээд : 
			
			explicit string (size_t n);
			
			неявная перегрузка операторов
			
			operator int() {
				---
				return x;
			}
		
		9) static fields and metods
			
			поля и методы относятся ко всему классу, а не к объекту
			
			статическая переменная
				счетчик который инкрементируется при вызове функции
			статический метод имеет доступ только к static полям
				
			как обратиться к статическому методу класса ? Через двойное двоеточие
			
			Class :: static_fun();
			
			(вау получается std:: cout типа , вау (он ничего не понял))
			
		10) pointers to memebers;
		
			int S::* p = &S::x;
			
			это адская фигня окольными путями дает ссылку x из класса S в переменную p
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			

			
			
		














