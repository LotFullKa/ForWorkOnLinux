					Указатели, функции и 
				 	   классные штуки
  1) Pointers (указатели)
  	
  	унарная звуздочка ! 
  	FE: type p
  	    type* p
  	итак указатели можно вертеть !
  	например: p + 1; 
  		  p ++; 	- next pointer in memory
  		  q - p;
  		  
  	void*  - указатель не иницилизрованной памяти
  	nullprt - указатель в никуда :)
  		  разименование такого указатея даст UB
  
  2) Arrays (Массивы)
  	type A[10] - выделили память на 10 элементов типа type
  	type* b = a - array to pointer conversion / указатель на массив
  	A[i] - обращение к массиву по индексу - это указатель на i-ый элемент массива
  
  3) Functions (функции)
  	Синтаксис функций:
  	
  	type f ( "arguments", ... ){		\\занятно, в аргументах, это не оператор запятая
  						\\а синтаксис конструкции функции 
  	}
  	
  	Перегружать функции - это нормально, это не гейство ! Можно и с разными аргументами
	type f (int);
	type f (double);
	
		overloading resalution - разрешение перегрузки
	это алгоритм выбора функции при множественном выборе. Компилятор будет подстраиваться
	в зависимости от типа переменных. Компилятор подбирает самую подходящую.
		Ambiguous call - нашлось несколько несколько функци с равным преоритетом выбор
	
		УкАзАтЕлИ на функции 		\\ "стремный синтаксис" Мещерин
	синтаксис:
	int f(double);
	int(*)(double) pf = f;
	
		Аргументы по умолчанию
	*информация*
	
		inline 
	заставляет считать все без прыжков по строкам кода
	компилятор вообще сам делает это за тебя, и инлайнит лучше тебя, и знает где это и когда
	стоит делать. А еще он тебе не общеает что сделает инлайн, если ты это напишешь.
	Так что соси сосиску.
	
  4) Staic and dynamic memory (статическая память, не изменная б)
  		Статическая память
  	static int x = 0;		\\ эта переменная будет храниться до конца программы	
	если выйти из функции и вернуться туда х не поменяется
	
		Динамическая память
	иногда нужно больше памяти чем зарезервировано
	type* p = new type (..);	\\зарезервировали память для переменной с указателем p
	delete p; 			\\освободили память после выделения
	
	Если вы в ходе программы потеряли указатель на выделенную память.
	то, естественно, вы проебались и освободить этот кусок памяти не можете
	Это называется утечка памяти !
	
	Если вы не освободили память по указателю -- утечка памяти
	Если освободили память по указателю однажды -- умничка !
	Если освободили память по указателю несколько раз -- ууу, сука, memory segmentation
	
	Динамическая память для массива:
	type* p = new type[n];		\\выделили память
	delete[] p;
	
  5) Reference Ссылки !
  	пример:
  	void swap (int x, int y){
  		int t = x;
  		x = y;
  		y = t;
  	}
  	
  	x and y - не поменяются вне этой функции, так как их значения локальны, чтобы
  	поменять значение вне этой области видимости, нужно пользоваться ссылками
  	
  	type x;
  	type y = x;		-- создай копию х и назови ее y;
  	
  	type x;
  	type& y = x;		-- создай название y, но это просто другое имя для объекта x;
  				   отныне и навсегда это два имени одного объекта
	

	int& f(){
	        int x;
	        return x;	-- Undefinded Behavior
	}

  6) Constant (константа)
  	существуют операции константные и нет
  	над константными переменными можно использовать только констаные операции
  	
  	допускается неявное преоборазование неконстантного выражения в константный
  	
  	const int x = 3;		--нельзя объявить не инициализировав
  	
  	const int* p = new int		--константные указатели
  					  для него запрещены p = 1;
  					  		     p++;
 		константные ссылки
	Сами ссылки ВСЕГДА константные !
	константными ссылками называют ссылки НА КОНСТАНТЫ
	
	type x = 1;			--ух гля, x то я поменять могу!
	const type& y = x;		--ух гля, а y я никак поменять не могу, хотя это все еще один объект
		
		константные ссылки - продление жизни 
	what
	
  7) static_cast<type>(expression)
  	приведение типов - то что вам нужно
  	
  		Запрещенные заклинания:
  	  1. заклинание
  	reinterpret_cast< >(..);	--вот смотри инт лежит - теперь думай что это флоат (что зачем это нужно)
  	у него есть менее уродливые сыны 
  	reinterpret_cast<type*>(..)		--теперь указатель имеет другой тип, И КОГДА ОН БУДЕТ РАЗИМЕНОВЫВАТЬ он разименует это как новый тип укзаателя
  	reinterpret_cast<type&>(..)		--тоже самое только ссылка
  	
  	type y = reinterpret_cast<type&>( x )
  	
  	  2. заклинание
  	const_cast			--способ сказать "заткнись компилятор" (не надо так)
  	  3. заклинание
  	какой то multy_cast честно прослушал, но он делает, что подбирает все это дерьмо и пытается выполнить хоть что-то
  	
  	
  	
  	
  	 



















