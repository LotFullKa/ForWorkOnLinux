					Тема : наследование
					
		1)	инкапсуляция - кнопочки есть ( интерфейс ), а вот реализацию вы не знаете
			
		3)	Идея и синтаксис объявления
			
			public - всем
			private - только своим методам и друзьям
			protected - своим методам, друзьям и наследникам
			
			class Derived : public Base {
				---
			};
			
			это значит что Derived наследник public Base - то есть ему будут доступны все методы public Base + те которые будут описаны внутри
			
			в случае private Base - закрывают наследуемые методы и поля
					 protected Base
			
			такой способ наследования - это способ инкапсуляции, чтобы никто не видел реализации предыдущего
			
			см. пример с пердежом в */OOP_lessons/untitled/untitled/main.cpp
			
			А как работают конструкторы ?
			
			Если у Base есть конструктор не дефолтный
			
			Base(int a).a(a) {}
			то вызывать Derived, то есть его конструктор нужно передавая аргументы для конструкторы наследуемого класса
			
			Derived(int a, int b, int c) : Base(a), a(b), b(c) {}  
		
		2)  небольшая путаница наследования имен ( тут все логично ) 
		
			struct Granny{
				int a;
				void f();
			};
			
			struct Mom : private Granny{
				int b;
				void f(int);
			};
			
			struct Son : public Mom {
				int c;
			private:
				void f(double);
			};
			
			и так если будет такой код: 
			Son bitch;
			bitch.f(1);
			
			то он скажет иди нахуй, потому что она приват, всмысле ты хочешь взять функцию от мамы ? Ты ее перекрыл ее своей.
			Короче имя функции перекрывается и он больше не может к ней обратиться напрямую нужно написать 
			
			bitch.Mom::f(1);
			
			допустим у нас нет функции f в Сыне, сможем ли мы вызвать функцию f бабушки ? Нет, мама запрещает посещать бабушку, хотя бабушка разрешает функцию.
			Аналогично если бы бабушка запрещала f, а мама разрешала Бабушку. Нужно чтобы все все разрешали. Пиздец ирерархия.
			
			Поговорим о Мега Бабушках ! ! !
			
			 
			struct Granny{
				int a;
				void f();
			};
			
			struct Mom : private Granny{
				frriend Son 			\\ Мама РАЗРЕШАЕТ ПОЙТИ К БАБУШКЕ 
				int b;
				void f(int);
			};
			
			struct Son : public Mom {
				int c;
			private:
				void f(double){
					Granny g				\\ (с исключением строки с friend у в теле мамы) Вот такой пиздец нельзя, 
											\\ потому что Сын в таком обращении имеет ввиду СВОЮ бабушку !
											\\ А такое обращение запрещено, потому что Бабушка сына для сына закрыта. ОДНАКО
											
				 	::Granny g 				\\ Даст обратиться, будет считать ее глобальной бабушкой, никак не связанной с сыном
				 							\\ Так сказать Мега Бабка ! 
				}
			};
			
