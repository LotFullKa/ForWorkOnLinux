					Тема : наследование
					
		1)	инкапсуляция - кнопочки есть ( интерфейс ), а вот реализацию вы не знаете
			
		3)	Идея и синтаксис объявления
			
			public - всем
			private - только своим методам и друзьям
			protected - своим методам, друзьям и наследникам
			
			class Derived : public Base {
				---
			};
			
			это значит что Derived наследник public Base - то есть ему будут доступны все методы public Base + те которые будут описаны внутри
			
			в случае private Base - закрывают наследуемые методы и поля
					 protected Base
			
			такой способ наследования - это способ инкапсуляции, чтобы никто не видел реализации предыдущего
			
			см. пример с пердежом в */OOP_lessons/untitled/untitled/main.cpp
			
			А как работают конструкторы ?
			
			Если у Base есть конструктор не дефолтный
			
			Base(int a).a(a) {}
			то вызывать Derived, то есть его конструктор нужно передавая аргументы для конструкторы наследуемого класса
			
			Derived(int a, int b, int c) : Base(a), a(b), b(c) {}  
		
		2)  небольшая путаница наследования имен ( тут все логично ) 
		
			struct Granny{
				int a;
				void f();
			};
			
			struct Mom : private Granny{
				int b;
				void f(int);
			};
			
			struct Son : public Mom {
				int c;
			private:
				void f(double);
			};
			
			и так если будет такой код: 
			Son bitch;
			bitch.f(1);
			
			то он скажет иди нахуй, потому что она приват, всмысле ты хочешь взять функцию от мамы ? Ты ее перекрыл ее своей.
			Короче имя функции перекрывается и он больше не может к ней обратиться напрямую нужно написать 
			
			bitch.Mom::f(1);
			
			допустим у нас нет функции f в Сыне, сможем ли мы вызвать функцию f бабушки ? Нет, мама запрещает посещать бабушку, хотя бабушка разрешает функцию.
			Аналогично если бы бабушка запрещала f, а мама разрешала Бабушку. Нужно чтобы все все разрешали. Пиздец ирерархия.
			
			Поговорим о Мега Бабушках ! ! !
			
			 
			struct Granny{
				int a;
				void f();
			};
			
			struct Mom : private Granny{
				frriend Son 			\\ Мама РАЗРЕШАЕТ ПОЙТИ К БАБУШКЕ 
				int b;
				void f(int);
			};
			
			struct Son : public Mom {
				int c;
			private:
				void f(double){
					Granny g				\\ (с исключением строки с friend у в теле мамы) Вот такой пиздец нельзя, 
											\\ потому что Сын в таком обращении имеет ввиду СВОЮ бабушку !
											\\ А такое обращение запрещено, потому что Бабушка сына для сына закрыта. ОДНАКО
											
				 	::Granny g 				\\ Даст обратиться, будет считать ее глобальной бабушкой, никак не связанной с сыном
				 							\\ Так сказать Мега Бабка ! 
				}
			};
			
			
12.03.20

			4) Multiple inheritance (мульти наследование)
			
			diamond problem (параллелограм наследование) 

								картинка https://media.geeksforgeeks.org/wp-content/cdn-uploads/20190612120714/diamond-problem-solution.png
								
			проблема наследования и перекрытия имен
			
			ее можно решить объявив родителя виртуальным, тогда создастся лишь один объект ( родитель ) верхняя часть ромба 
			
			class Square: public virtual Rhobus{};			\\объявление виртуального родителя
			
			так как в памяти такая фигня может быть дефрагментирована. Поэтому после такого объявления класс будет создан в  памяти как :
			сначала указатель на "таблица инструкций объектов"
			
			5) приведение типов между родетелем и наследником
				ух, важный топик
													
												int x; Base	void f()
														^
														|
														|
												int y; Derived void f()
			
			Derived d;
			Base* bp = &d;
			Base& b = d;
			b, f();
			
			slicing ( срез )
			Base bb = d;						\\скопируй частб Derive которые были в Base и скопируй ее
			
			потом было про виртуальные  функции но я уснул
